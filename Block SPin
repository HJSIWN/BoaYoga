repeat wait(0.1) until game.Players and game.Players.LocalPlayer and game.Players.LocalPlayer.Character

local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/MQPS7/SOMTANK-UI-OpenSrc/refs/heads/main/V1"))()

PathfindingService = game:GetService("PathfindingService")
TweenService = game:GetService("TweenService")
RunService = game:GetService("RunService")
Lighting = game:GetService("Lighting")
replicatedStorage = game:GetService("ReplicatedStorage")
UIS = game:GetService("UserInputService")
vim = game:GetService("VirtualInputManager")
UIS = game:GetService("UserInputService")
GuiService = game:GetService("GuiService")

player = game.Players.LocalPlayer
character = player.Character
humanoid = character:FindFirstChildOfClass("Humanoid")
HMNRT = character:FindFirstChild("HumanoidRootPart")
Camera = workspace.CurrentCamera
screenSize = Camera.ViewportSize
plrGui = player.PlayerGui

SomtankInfo  = Instance.new("Folder", workspace)
ScreenGui = Instance.new("ScreenGui", game:GetService("CoreGui"))
UiIs_Close = false
SomtankInfo.Name = "SomtankInfo"

local function MakeDraggableButton(button: ImageButton, MoveFrame)
	local dragging = false;	local dragStart
	local startPos;	local firstPos
	button.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = true
			dragStart = input.Position
			Icon_Position = button.Position
			startPos = MoveFrame.Position
			if not firstPos then
				firstPos = MoveFrame.Position
			end
		end
	end)
	UIS.InputChanged:Connect(function(input)
		if dragging and (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement) then
			local delta = input.Position - dragStart
			MoveFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
		end
	end)
	UIS.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = false
		end
	end)
end
local function MakeImageButton(Parent, Size, Posi, BGtran, Color, Imtran, imageID)
	local NewFrame = Instance.new("ImageButton", Parent)
	local UICorner = Instance.new("UICorner", NewFrame)
	NewFrame.Position = Posi
	NewFrame.Size = Size
	NewFrame.BackgroundTransparency = BGtran
	NewFrame.Image = imageID or ""
	NewFrame.ImageTransparency = Imtran
	NewFrame.BackgroundColor3 = Color
	NewFrame.ImageColor3 = Color
	NewFrame.ZIndex = 2
	return NewFrame
end
local MoveIcon = MakeImageButton(ScreenGui, UDim2.new(0, 53,0, 51), UDim2.new(0.100, 0,0.447, 0), 1, Color3.new(1, 1, 1), 0, "rbxassetid://81129676934693")
local FOR_MoveIcon = Instance.new("UIAspectRatioConstraint", MoveIcon)
MakeDraggableButton(MoveIcon, MoveIcon)
MoveIcon.Activated:Connect(function()
	if Icon_Position == MoveIcon.Position then
		vim:SendKeyEvent(true, Enum.KeyCode.Insert, false, game)
		UiIs_Close = true
		task.wait(0.05)
		vim:SendKeyEvent(false, Enum.KeyCode.Insert, false, game)
	end
end)

--- EXAMPLE !!!

function gradient(text, startColor, endColor)
	local result = ""
	local length = #text

	for i = 1, length do
		local t = (i - 1) / math.max(length - 1, 1)
		local r = math.floor((startColor.R + (endColor.R - startColor.R) * t) * 255)
		local g = math.floor((startColor.G + (endColor.G - startColor.G) * t) * 255)
		local b = math.floor((startColor.B + (endColor.B - startColor.B) * t) * 255)

		local char = text:sub(i, i)
		result = result .. "<font color=\"rgb(" .. r ..", " .. g .. ", " .. b .. ")\">" .. char .. "</font>"
	end

	return result
end

local Window = WindUI:CreateWindow({
	Title = "Somtank",
	Icon = "rbxassetid://80019916158199",
	IconThemed = true,
	Author = "v0.0.1",
	Folder = "Somtank",
	Size = UDim2.fromOffset(460, 320),
	Transparent = true,
	Theme = "Violet",
	User = {
		Enabled = true,
		Callback = function() end,
		Anonymous = false
	},
	SideBarWidth = 200,
	ScrollBarEnabled = true,
})

getgenv().TranslateEnv = "Thai"

if getgenv().MainButton677 then
	getgenv().MainButton677:Destroy()
	getgenv().MainButton677 = ScreenGui
else
	getgenv().MainButton677 = ScreenGui
end

Window:EditOpenButton({
	Title = "Open Example UI",
	Icon = "monitor",
	CornerRadius = UDim.new(0,16),
	StrokeThickness = 2,
	Color = ColorSequence.new(Color3.fromHex("FF0F7B"),Color3.fromHex("F89B29")),
	Enabled = false,
	Draggable = true,
})

local Tabs = {}

do
	Tabs.Player = Window:Section({
		Title = "กลุ่ม 1",
		Opened = true,
	})
	
	--Tabs.Mode1 = Tabs.Player:Tab({ Title = "ผู้เล่น", Icon = "rbxassetid://2795572800" })
	Tabs.Mode2 = Tabs.Player:Tab({ Title = "ฟาร์ม", Icon = "rbxassetid://9008236330" })
	
end

Window:SelectTab(1)

local function tweenPart(fromPart, toPart, time, easingStyle, offset)
	local targetCFrame = toPart.CFrame
	if offset then
		targetCFrame = (toPart.CFrame * CFrame.new(offset.X, offset.Y, offset.Z))
	end
	local tweenInfo = TweenInfo.new(time,Enum.EasingStyle[easingStyle],Enum.EasingDirection.Out)
	local tween = TweenService:Create(fromPart, tweenInfo, {CFrame = targetCFrame})
	tween:Play()
end

local UsePathFinding = false
local function smartWalkTo(targetPosition)
	
	UsePathFinding = true

	if not character or not humanoid or not HMNRT then
		print("Character not ready")
		return
	end

	-- สร้าง Path
	local function createPath(startPos, endPos)
		local path = PathfindingService:CreatePath({
			AgentRadius = 2,
			AgentHeight = 5,
			AgentCanJump = true
		})

		local success = pcall(function()
			path:ComputeAsync(startPos, endPos)
		end)

		if success and path.Status == Enum.PathStatus.Success then
			return path:GetWaypoints()
		end
		return nil
	end

	-- ตรวจสอบว่าติดหรือไม่
	local function isStuck(lastPos, currentPos, threshold)
		return (currentPos - lastPos).Magnitude < (threshold or 0.5)
	end

	-- หาตำแหน่งสุ่ม
	local function getRandomPosition(centerPos, range)
		local angle = math.random() * math.pi * 2
		local distance = math.random(5, range or 10)
		return Vector3.new(
			centerPos.X + math.cos(angle) * distance,
			centerPos.Y,
			centerPos.Z + math.sin(angle) * distance
		)
	end

	-- เดินตาม waypoints
	local function walkPath(waypoints)
		for i, waypoint in ipairs(waypoints) do
			-- กระโดดถ้าจำเป็น
			if waypoint.Action == Enum.PathWaypointAction.Jump then
				humanoid.Jump = true
			end

			humanoid:MoveTo(waypoint.Position)

			local startTime = tick()
			local lastPosition = HMNRT.Position
			local reached = false

			-- รอจนถึง waypoint
			while not reached and (tick() - startTime) < 5 do
				if UsePathFinding == true then
					wait(0.1)

					local currentPos = HMNRT.Position
					local distanceToWaypoint = (currentPos - waypoint.Position).Magnitude

					-- ถึง waypoint แล้ว
					if distanceToWaypoint <= 4 then
						reached = true
						break
					end

					-- ตรวจสอบการติด
					if tick() - startTime > 2 then
						if isStuck(lastPosition, currentPos, 1) then
							-- ติด - ลองแก้ไข
							humanoid.Jump = true
							wait(0.2)

							-- เลื่อนตำแหน่ง
							local cf = HMNRT.CFrame
							HMNRT.CFrame = cf * CFrame.new(
								math.random(-2, 2),
								0,
								math.random(-2, 2)
							)
							wait(0.2)

							humanoid:MoveTo(waypoint.Position)
							lastPosition = HMNRT.Position
							startTime = tick()
						end
					end
				end
			end

			-- ถ้าไม่ถึงข้ามไป
			if not reached then
				print("Skip waypoint " .. i)
			end
		end

		-- ตรวจสอบว่าถึงเป้าหมายแล้วหรือไม่
		local finalDistance = (HMNRT.Position - targetPosition).Magnitude
		return finalDistance <= 6
	end

	-- ลองเดิน
	local function attemptWalk(destination)
		local waypoints = createPath(HMNRT.Position, destination)
		if waypoints then
			return walkPath(waypoints)
		end
		return false
	end

	print("Walking to: " .. tostring(targetPosition))

	-- ลองเดินไปเป้าหมายโดยตรง
	local success = attemptWalk(targetPosition)

	-- ถ้าไม่สำเร็จ ลองอีก 3 ครั้ง
	local attempts = 0
	while not success and attempts < 3 do
		if UsePathFinding == true then
			attempts = attempts + 1
			print("Retry " .. attempts)

			-- เดินไปตำแหน่งสุ่มก่อน
			local randomPos = getRandomPosition(targetPosition, 15)
			local reachedRandom = attemptWalk(randomPos)

			if reachedRandom then
				wait(1)
				-- ลองเดินไปเป้าหมายอีกครั้ง
				success = attemptWalk(targetPosition)
			else
				-- ถ้าเดินไปตำแหน่งสุ่มไม่ได้ เลื่อนตัวแล้วลองใหม่
				HMNRT.CFrame = HMNRT.CFrame * CFrame.new(
					math.random(-3, 3),
					0,
					math.random(-3, 3)
				)
				wait(1)
			end
		end
	end

	if success then
		print("Reached target!")
	else
		print("Failed to reach target")
	end

	return success
end

local function IsNear(pos1, pos2, maxDist)
	return (pos1 - pos2).Magnitude <= maxDist
end

local function matchesAllowedKeyword(value, allowedKeywords)
	value = value:lower()
	for _, keyword in ipairs(allowedKeywords) do
		if string.find(value, keyword:lower()) then
			return true
		end
	end
	return false
end

local function ScanNear(Folder, MainPosition, TargetName)
	local NearPart = nil
	local NearDis = math.huge
	for i,v in ipairs(Folder:GetChildren()) do
		local dis = (MainPosition - v.Position).Magnitude
		if TargetName then
			if matchesAllowedKeyword(v.Name, TargetName) then
				if dis < NearDis then
					NearDis = dis
					NearPart = v
				end
			end
		else
			if dis < NearDis then
				NearDis = dis
				NearPart = v
			end
		end
	end
	return NearPart, NearDis
end

local function Translate(ThaiLang, EngLang)
	local Resut = ThaiLang
	if getgenv().TranslateEnv then
		if getgenv().TranslateEnv == "Thai" then
			Resut = ThaiLang
		elseif getgenv().TranslateEnv == "Eng" then
			Resut = EngLang
		end
	end
	return Resut
end


Map = workspace:WaitForChild("Map")

ApplyJob_Button = plrGui:WaitForChild("JobApplication"):WaitForChild("JobApplicationFrame"):WaitForChild("ApplyJob")

--Player_Level = player:GetAttribute("level")

JobBegin_BurgePlaceBeacon = workspace:WaitForChild("BurgePlaceBeacon"):WaitForChild("TouchPart")


--game:GetService("Players").LocalPlayer.PlayerGui.TopRightHud.Holder.Frame.MoneyTextLabel

local MoneyTextLabel = plrGui:WaitForChild("TopRightHud"):WaitForChild("Holder"):WaitForChild("Frame"):WaitForChild("MoneyTextLabel")
local PlayerMoney = MoneyTextLabel.ContentText:match("%d+")
task.spawn(function()
	while true do
		PlayerMoney = MoneyTextLabel.ContentText:match("%d+") ; wait(1)
	end
end)

Depositing = false
AutoDepositMoney = false
Tabs.Mode2:Toggle({
	Title = Translate("ออโต้ฝากเงิน", "Auto deposit"),
	Value = false,
	Callback = function(state)
		AutoDepositMoney = state
	end
})

DepositMoneyWhen = 500
Tabs.Mode2:Slider({
	Title = Translate("จำนวนที่ต้องการฝาก", "Amount to be deposited"),
	Value = {
		Min = 50,
		Max = 10000,
		Default = 500,
	},
	Callback = function(value)
		DepositMoneyWhen = value
	end
})

task.spawn(function()
	local ATMs = workspace:WaitForChild("Map"):WaitForChild("Props"):WaitForChild("ATMs")
	local Get = game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Get")
	local ATMNear = nil
	local HowNearATM = math.huge
	local AreaPart = nil
	while true do
		if AutoDepositMoney == true then
			if PlayerMoney >= DepositMoneyWhen then
				Depositing = true
				task.wait(1)
				--workspace.Map.Props.ATMs.ATM.Part.Screen
				
				for i,v in ipairs(ATMs:GetChildren()) do
					if v:FindFirstChild("Area") then
						local Area = v:FindFirstChild("Area")
						local Dis = (HMNRT.Position - Area.Position).Magnitude
						if Dis < HowNearATM then
							HowNearATM = Dis
							ATMNear = v
							AreaPart = Area
						end
					end
				end
				
				if ATMNear and AreaPart then
					for i2,v2 in ipairs(ATMNear:GetDescendants()) do
						if v2.Name == "Screen" and v2:IsA("SurfaceGui") then
							local SurfaceGui = v2
							if SurfaceGui.Enabled == false then

							end
						end
					end
					HowNearATM = math.huge
					ATMNear = nil
					AreaPart = nil
					Depositing = false
				end
			end
		end
		task.wait(3)
	end
end)




Tabs.Mode2:Divider()

NameNeedKill = { "SmallPuddle" }
Tabs.Mode2:Dropdown({
	Title = Translate("แอ่งน้ำที่ต้องการถู", "The puddle that needs to be mopped"),
	Values = { "SmallPuddle", "LargePuddle", "NastyPuddle"
		, "OilPuddle", "ToxicPuddle",},
	Value = { "SmallPuddle" },
	Multi = true,
	AllowNone = true,
	Callback = function(option) 
		NameNeedKill = option
	end
})

Mob_Farm = false
Tabs.Mode2:Toggle({
	Title = Translate("ออโต้ทำงานถูพื้น", "Auto floor mopping"),
	Value = false,
	Callback = function(state) 
		Mob_Farm = state
		if Mob_Farm == true then
			vim:SendKeyEvent(true, Enum.KeyCode.LeftShift, false, game)
			WindUI:Notify({
				Title = "คุณได้เปิดฟังชั่น",
				Content = "ออโต้ทำงานถูพื้น",
				Duration = 5,
			})
			for i,v in ipairs(workspace:GetDescendants()) do
				if v.Name == "DoorSystem" then
					v:Destroy()
				end
			end
		else
			vim:SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
			WindUI:Notify({
				Title = "คุณได้ปิดฟังชั่น",
				Content = "ออโต้ทำงานถูพื้น",
				Duration = 5,
			})
		end
	end
})

task.spawn(function()
	local Puddles = Map:WaitForChild("Tiles"):WaitForChild("BurgerPlaceTile"):WaitForChild("BurgerPlace"):WaitForChild("Interior"):WaitForChild("Puddles")
	local StuckMob = 0
	local SomtankInfo_Puddles = Instance.new("Folder", SomtankInfo)
	SomtankInfo_Puddles.Name = "SomtankInfo_Puddles"
	
	while true do
		if Mob_Farm then
			if player:GetAttribute("Job") == "" then
				repeat
					local smartWalkToJobBegin =	smartWalkTo(JobBegin_BurgePlaceBeacon.Position)
					repeat
						task.wait(1)
					until smartWalkToJobBegin and smartWalkToJobBegin == true
					GuiService.SelectedObject = ApplyJob_Button
					task.wait(0.1)
					vim:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
					task.wait(0.05)
					vim:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
					task.wait(0.1)
					GuiService.SelectedObject = nil
					task.wait(1)
				until player:GetAttribute("Job") == "janitor" or Mob_Farm == false or Depositing == false
				WindUI:Notify({
					Title = "สมัครงานถูพื้น",
					Content = "สำเร็จ",
					Duration = 5,
				})
				UsePathFinding = false
			else
				repeat
					repeat
						task.wait(0.5)
					until Depositing == false
					if not character:FindFirstChild("Mop") then
						if player.Backpack:FindFirstChild("Mop") then
							player.Backpack.Mop.Parent = character
						end
					end
					local NearPart = ScanNear(Puddles, HMNRT.Position, NameNeedKill)
					if NearPart then
						local smartWalkToPuddles =	smartWalkTo(NearPart.Position)
						repeat
							task.wait(0.5)
						until smartWalkToPuddles and smartWalkToPuddles == true or Depositing == false
						repeat
							StuckMob = StuckMob + 0.5
							task.wait(0.5)
						until NearPart.Size.Z < 0.002 or StuckMob >= 6 or Depositing == false
						UsePathFinding = false
						StuckMob = 0
						NearPart.Parent = SomtankInfo_Puddles
						WindUI:Notify({
							Title = "ถูพื้น",
							Content = "สำเร็จ",
							Duration = 5,
						})
						task.wait(0.1)
						if #SomtankInfo_Puddles:GetChildren() > 3 then
							for _, item in ipairs(SomtankInfo_Puddles:GetChildren()) do
								if item.Size.Z > 0.002 then
									item.Parent = Puddles
								end
							end
						end
					end
					task.wait(0.1)
				until Mob_Farm == false 
			end
		end
		task.wait(1)
	end
end)

Tabs.Mode2:Divider()







-- Configuration / Optional

local HttpService = game:GetService("HttpService")

local folderPath = "WindUI"
makefolder(folderPath)

local function SaveFile(fileName, data)
	local filePath = folderPath .. "/" .. fileName .. ".json"
	local jsonData = HttpService:JSONEncode(data)
	writefile(filePath, jsonData)
end
local function LoadFile(fileName)
	local filePath = folderPath .. "/" .. fileName .. ".json"
	if isfile(filePath) then
		local jsonData = readfile(filePath)
		return HttpService:JSONDecode(jsonData)
	end
end
local function ListFiles()
	local files = {}
	for _, file in ipairs(listfiles(folderPath)) do
		local fileName = file:match("([^/]+)%.json$")
		if fileName then
			table.insert(files, fileName)
		end
	end
	return files
end
local themeValues = {}
for name, _ in pairs(WindUI:GetThemes()) do
	table.insert(themeValues, name)
end
local filesDropdown
local files = ListFiles()
local currentThemeName = WindUI:GetCurrentTheme()
local themes = WindUI:GetThemes()
local ThemeAccent = themes[currentThemeName].Accent
local ThemeOutline = themes[currentThemeName].Outline
local ThemeText = themes[currentThemeName].Text
local ThemePlaceholderText = themes[currentThemeName].Placeholder
function updateTheme()
	WindUI:AddTheme({
		Name = currentThemeName,
		Accent = ThemeAccent,
		Outline = ThemeOutline,
		Text = ThemeText,
		Placeholder = ThemePlaceholderText
	})
	WindUI:SetTheme(currentThemeName)
end
local InviteCode = "ApbHXtAwU2"
local DiscordAPI = "https://discord.com/api/v10/invites/" .. InviteCode .. "?with_counts=true&with_expiration=true"
local Response = game:GetService("HttpService"):JSONDecode(WindUI.Creator.Request({
	Url = DiscordAPI,
	Method = "GET",
	Headers = {
		["User-Agent"] = "RobloxBot/1.0",
		["Accept"] = "application/json"
	}
}).Body)
Tabs.Mode2:Keybind({
	Title = "ปุ่มเปิดปิดหน้าต่าง",
	Desc = "สามารถเซ้ทได้",
	Value = "Insert",
	Callback = function(v)
		Window:SetToggleKey(Enum.KeyCode[v])
	end
})
local function parseJSON(luau_table, indent, level, visited)
	indent = indent or 2
	level = level or 0
	visited = visited or {}

	local currentIndent = string.rep(" ", level * indent)
	local nextIndent = string.rep(" ", (level + 1) * indent)

	if luau_table == nil then
		return "null"
	end

	local dataType = type(luau_table)

	if dataType == "table" then
		if visited[luau_table] then
			return "\"[Circular Reference]\""
		end

		visited[luau_table] = true

		local isArray = true
		local maxIndex = 0

		for k, _ in pairs(luau_table) do
			if type(k) == "number" and k > maxIndex then
				maxIndex = k
			end
			if type(k) ~= "number" or k <= 0 or math.floor(k) ~= k then
				isArray = false
				break
			end
		end

		local count = 0
		for _ in pairs(luau_table) do
			count = count + 1
		end
		if count ~= maxIndex and isArray then
			isArray = false
		end

		if count == 0 then
			return "{}"
		end

		if isArray then
			if count == 0 then
				return "[]"
			end

			local result = "[\n"

			for i = 1, maxIndex do
				result = result .. nextIndent .. parseJSON(luau_table[i], indent, level + 1, visited)
				if i < maxIndex then
					result = result .. ","
				end
				result = result .. "\n"
			end

			result = result .. currentIndent .. "]"
			return result
		else
			local result = "{\n"
			local first = true

			local keys = {}
			for k in pairs(luau_table) do
				table.insert(keys, k)
			end
			table.sort(keys, function(a, b)
				if type(a) == type(b) then
					return tostring(a) < tostring(b)
				else
					return type(a) < type(b)
				end
			end)

			for _, k in ipairs(keys) do
				local v = luau_table[k]
				if not first then
					result = result .. ",\n"
				else
					first = false
				end

				if type(k) == "string" then
					result = result .. nextIndent .. "\"" .. k .. "\": "
				else
					result = result .. nextIndent .. "\"" .. tostring(k) .. "\": "
				end

				result = result .. parseJSON(v, indent, level + 1, visited)
			end

			result = result .. "\n" .. currentIndent .. "}"
			return result
		end
	elseif dataType == "string" then
		local escaped = luau_table:gsub("\\", "\\\\")
		escaped = escaped:gsub("\"", "\\\"")
		escaped = escaped:gsub("\n", "\\n")
		escaped = escaped:gsub("\r", "\\r")
		escaped = escaped:gsub("\t", "\\t")

		return "\"" .. escaped .. "\""
	elseif dataType == "number" then
		return tostring(luau_table)
	elseif dataType == "boolean" then
		return luau_table and "true" or "false"
	elseif dataType == "function" then
		return "\"function\""
	else
		return "\"" .. dataType .. "\""
	end
end

local function tableToClipboard(luau_table, indent)
	indent = indent or 4
	local jsonString = parseJSON(luau_table, indent)
	setclipboard(jsonString)
	return jsonString
end


-- 1. Load ConfigManager
local ConfigManager = Window.ConfigManager


-- 2. Create Config File                    ↓ Config File name
local myConfig = ConfigManager:CreateConfig("myConfig")


-- 3. Register elements

--               | ↓ Element name (no spaces)  | ↓ Element          |
myConfig:Register( "toggleNameExample",          ToggleElement      )
myConfig:Register( "sliderNameExample",          SliderElement      ) 
myConfig:Register( "keybindNameExample",         KeybindElement     )
myConfig:Register( "dropdownNameExample",        DropdownElement    )
myConfig:Register( "inputNameExample",           InputElement       )
myConfig:Register( "ColorpickerNameExample",     ColorpickerElement )



Window:OnClose(function()
	UiIs_Close = false
end)
